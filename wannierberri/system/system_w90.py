#                                                            #
# This file is distributed as part of the WannierBerri code  #
# under the terms of the GNU General Public License. See the #
# file `LICENSE' in the root directory of the WannierBerri   #
# distribution, or http://www.gnu.org/copyleft/gpl.txt       #
#                                                            #
# The WannierBerri code is hosted on GitHub:                 #
# https://github.com/stepan-tsirkin/wannier-berri            #
#                     written by                             #
#           Stepan Tsirkin, University of Zurich             #
#   some parts of this file are originate                    #
# from the translation of Wannier90 code                     #
#------------------------------------------------------------#

import numpy as np
import functools
import multiprocessing
from ..__utility import iterate3dpm, real_recip_lattice, fourier_q_to_R, alpha_A, beta_A
from .system import System
from ..__w90_files import EIG, MMN, CheckPoint, SPN, UHU, UIU, SIU, SHU
from time import time


class System_w90(System):
    """
    System initialized from the Wannier functions generated by `Wannier90 <http://wannier.org>`__ code.
    Reads the ``.chk``, ``.eig`` and optionally ``.mmn``, ``.spn``, ``.uHu``, ``.sIu``, and ``.sHu`` files

    Parameters
    ----------
    seedname : str
        the seedname used in Wannier90
    transl_inv : bool
        Use Eq.(31) of `Marzari&Vanderbilt PRB 56, 12847 (1997) <https://journals.aps.org/prb/abstract/10.1103/PhysRevB.56.12847>`_ for band-diagonal position matrix elements
    guiding_centers : bool
        If True, enable overwriting the diagonal elements of the AA_R matrix at R=0 with the
        Wannier centers calculated from Wannier90.
    npar : int
        number of processes used in the constructor
    fft : str
        library used to perform the fast Fourier transform from **q** to **R**. ``fftw`` or ``numpy``. (practically does not affect performance,
        anyway mostly time of the constructor is consumed by reading the input files)
    kmesh_tol : float
        tolerance to consider the b_k vectors (connecting to neighbouring k-points on the grid) belonging to the same shell
    bk_complete_tol : float
        tolerance to consider the set of b_k shells as complete.

    Notes
    -----
    see also  parameters of the :class:`~wannierberri.System`
    """

    def __init__(
            self,
            seedname="wannier90",
            transl_inv=True,
            #############
            ### Oscar ###
            #######################################
            transl_inv_JaeMo=False, # Activate Jae-Mo's method to deal with translational invariance
            transl_inv_OSD=False,   # Activate Convention I to deal with translational invariance
            #######################################
            guiding_centers=False,
            fft='fftw',
            npar=multiprocessing.cpu_count(),
            kmesh_tol=1e-7,
            bk_complete_tol=1e-5,
            **parameters):

        #############
        ### Oscar ###
        ########################################    
        if transl_inv_JaeMo or transl_inv_OSD:
            transl_inv=True        
        ########################################

        self.set_parameters(**parameters)
        self.npar = npar
        self.seedname = seedname

        chk = CheckPoint(self.seedname, kmesh_tol=kmesh_tol, bk_complete_tol=bk_complete_tol)
        self.real_lattice, self.recip_lattice = real_recip_lattice(chk.real_lattice, chk.recip_lattice)
        if self.mp_grid is None:
            self.mp_grid = chk.mp_grid
        self.iRvec, self.Ndegen = self.wigner_seitz(chk.mp_grid)
        self.nRvec0 = len(self.iRvec)
        self.num_wann = chk.num_wann
        self.wannier_centers_cart_auto = chk.wannier_centers

        eig = EIG(seedname)
        if self.need_R_any(['AA','BB']):
            mmn = MMN(seedname, npar=npar)

        kpt_mp_grid = [
            tuple(k) for k in np.array(np.round(chk.kpt_latt * np.array(chk.mp_grid)[None, :]), dtype=int) % chk.mp_grid
        ]
        if (0, 0, 0) not in kpt_mp_grid:
            raise ValueError(
                "the grid of k-points read from .chk file is not Gamma-centered. Please, use Gamma-centered grids in the ab initio calculation"
            )

        fourier_q_to_R_loc = functools.partial(
            fourier_q_to_R,
            mp_grid=chk.mp_grid,
            kpt_mp_grid=kpt_mp_grid,
            iRvec=self.iRvec,
            ndegen=self.Ndegen,
            numthreads=npar,
            fft=fft)

        #########
        # Oscar #
        ############################################################################################################
        
        timeFFT = 0
        HHq = chk.get_HH_q(eig)
        t0 = time()
        HH_R = fourier_q_to_R_loc(HHq)
        self.set_R_mat('Ham', HH_R)
        timeFFT += time() - t0

        centers=chk.wannier_centers     
        R_cart = self.iRvec.dot(self.real_lattice)
        
        if self.need_R_any('AA'):
            AA_R = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)           
            AA_qb, bk_latt_unique = chk.get_AA_q(
                mmn, transl_inv=transl_inv, centers=centers, transl_inv_JaeMo=transl_inv_JaeMo, transl_inv_OSD=transl_inv_OSD)
            t0 = time()

            # Naive finite-difference scheme
            if (not transl_inv_JaeMo and not transl_inv_OSD):
                AA_R = np.sum(fourier_q_to_R_loc(AA_qb), axis=3)
                # Set diagonal parts
                for iw in range(self.num_wann): # Impose result from Convention I
                        AA_R[iw, iw, self.iR0, :] = 0.0

            # Jae-Mo's method
            if transl_inv_JaeMo:
                AA_Rb = fourier_q_to_R_loc(AA_qb)

                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):              
                    for ib in range(mmn.NNB):
                        AA_R[:, :, iR, :] += AA_Rb[:, :, iR, ib, :] * np.exp(-2j * np.pi * np.dot(bk_latt_unique[ib, :], self.iRvec[iR, :]) / 2) 

                # Set diagonal parts
                for iw in range(self.num_wann): # Impose result from Convention I       
                    AA_R[iw, iw, self.iR0, :] = 0.0 #self.wannier_centers_cart_auto[iw, :]

            # Convention I method
            if transl_inv_OSD:
                AA_Rb = fourier_q_to_R_loc(AA_qb)

                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib in range(mmn.NNB):
                        AA_R[:, :, iR, :] += AA_Rb[:, :, iR, ib, :]

                # Set diagonal parts
                for iw in range(self.num_wann): # Impose result from Convention I
                    AA_R[iw, iw, self.iR0, :] = 0.0 #self.wannier_centers_cart_auto[iw, :]

            timeFFT += time() - t0

            self.set_R_mat('AA',AA_R)

        if 'BB' in self.needed_R_matrices:
            BB_R = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)
            BB_R_recentered = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)
            BB_qb, bk_latt_unique = chk.get_BB_q(
                mmn, eig, transl_inv=transl_inv, centers=centers, transl_inv_JaeMo=transl_inv_JaeMo, transl_inv_OSD=transl_inv_OSD)
            t0 = time()

            # Naive finite-difference scheme
            if (not transl_inv_JaeMo and not transl_inv_OSD):
                BB_R = np.sum(fourier_q_to_R_loc(BB_qb), axis=3)

            # Jae-Mo's method
            if transl_inv_JaeMo:
                BB_Rb = fourier_q_to_R_loc(BB_qb)

                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib in range(mmn.NNB):
                        BB_R_recentered[:, :, iR, :] += BB_Rb[:, :, iR, ib, :] * np.exp(-2j * np.pi * np.dot(bk_latt_unique[ib, :], self.iRvec[iR, :]) / 2)

                # Compute the original real-space matrix elements from the "recentered" matrices
                for iR in range(self.nRvec0):
                    for iw in range(self.num_wann):
                        for jw in range(self.num_wann):
                            BB_R[iw, jw, iR, :] = BB_R_recentered[iw, jw, iR, :] - 0.5 * (self.iRvec[iR, :] + centers[jw, :] - centers[iw, :]) * HH_R[iw, jw, iR]

            # Convention I method
            if transl_inv_OSD:
                BB_Rb = fourier_q_to_R_loc(BB_qb)
                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib in range(mmn.NNB):
                        BB_R[:, :, iR, :] += BB_Rb[:, :, iR, ib, :]

            self.set_R_mat('BB',BB_R)
            timeFFT += time() - t0

        if 'CC' in self.needed_R_matrices:
            CC_R = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)
            uhu = UHU(seedname)
            CC_qb, b1k_latt_unique, b2k_latt_unique = chk.get_CC_q(
                mmn, uhu, transl_inv=transl_inv, centers=centers, transl_inv_JaeMo=transl_inv_JaeMo, transl_inv_OSD=transl_inv_OSD)
            t0 = time()

            # Naive finite-difference scheme
            if (not transl_inv_JaeMo and not transl_inv_OSD):
                CC_R = np.sum(fourier_q_to_R_loc(CC_qb), axis=(3,4))

            # Jae-Mo's method
            if transl_inv_JaeMo:
                CC_Rb = fourier_q_to_R_loc(CC_qb)

                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib1 in range(mmn.NNB):
                        for ib2 in range(mmn.NNB):
                            phase_b1 = np.exp(-2j * np.pi * np.dot(b1k_latt_unique[ib1,:], self.iRvec[iR,:])/2 )
                            phase_b2 = np.exp(-2j * np.pi * np.dot(b2k_latt_unique[ib2,:], self.iRvec[iR,:])/2 )
                            CC_R[:, :, iR, :] += CC_Rb[:, :, iR, ib1, ib2, :] * phase_b1 * phase_b2

                # Compute the original real-space matrix elements from the "recentered" matrices
                for iR in range(self.nRvec0):
                    for iw in range(self.num_wann):
                        for jw in range(self.num_wann):
                            CC_R_rc_B  = 1j * (centers[jw, alpha_A] - centers[iw, alpha_A] + self.iRvec[iR, alpha_A]) * BB_R_recentered[iw, jw, iR,  beta_A]
                            CC_R_rc_B -= 1j * (centers[jw,  beta_A] - centers[iw,  beta_A] + self.iRvec[iR,  beta_A]) * BB_R_recentered[iw, jw, iR, alpha_A]
                            CC_R_rc_H  = 0.5j * (centers[jw, alpha_A] - centers[iw, alpha_A]) * self.iRvec[iR,  beta_A]
                            CC_R_rc_H -= 0.5j * (centers[jw,  beta_A] - centers[iw,  beta_A]) * self.iRvec[iR, alpha_A]
                            CC_R_rc_H *= HH_R[iw, jw, iR]

                            CC_R[iw, jw, iR, :] = CC_R[iw, jw, iR, :] + CC_R_rc_B + CC_R_rc_H

            # Convention I method
            if transl_inv_OSD:
                CC_Rb = fourier_q_to_R_loc(CC_qb)
                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib1 in range(mmn.NNB):
                        for ib2 in range(mmn.NNB):
                            CC_R[:, :, iR, :] += CC_Rb[:, :, iR, ib1, ib2, :]

            self.set_R_mat('CC', CC_R)
            timeFFT += time() - t0
            del uhu

        if 'FF' in self.needed_R_matrices:
            FF_R = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)
            FF_R_recentered = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)
            uiu = UIU(seedname)
            FF_qb, b1k_latt_unique, b2k_latt_unique = chk.get_FF_q(
                mmn, uiu, transl_inv=transl_inv, centers=centers, transl_inv_JaeMo=transl_inv_JaeMo, transl_inv_OSD=transl_inv_OSD)
            t0 = time()

            # Naive finite-difference scheme
            if (not transl_inv_JaeMo and not transl_inv_OSD):
                FF_R = np.sum(fourier_q_to_R_loc(FF_qb), axis=(3,4))

            # Jae-Mo's method
            if transl_inv_JaeMo:
                FF_Rb = fourier_q_to_R_loc(FF_qb)
            
                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib1 in range(mmn.NNB):
                        for ib2 in range(mmn.NNB):
                            phase_b1 = np.exp(-2j * np.pi * np.dot(b1k_latt_unique[ib1,:], self.iRvec[iR,:])/2 )
                            phase_b2 = np.exp(-2j * np.pi * np.dot(b2k_latt_unique[ib2,:], self.iRvec[iR,:])/2 )
                            FF_R_recentered[:, :, iR, :] += FF_Rb[:, :, iR, ib1, ib2, :] * phase_b1 * phase_b2
            
                # Compute the original real-space matrix elements from the "recentered" matrices
                AA_Rb = fourier_q_to_R_loc(AA_qb)
                AA_R_rc = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)

                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib in range(mmn.NNB):
                        AA_R_rc[:, :, iR, :] += AA_Rb[:, :, iR, ib, :] * np.exp(-2j * np.pi * np.dot(bk_latt_unique[ib, :], self.iRvec[iR, :]) / 2) 

                # Set diagonal parts
                for iw in range(self.num_wann): # Impose result from Convention I       
                    AA_R_rc[iw, iw, self.iR0, :] = 0.0 #self.wannier_centers_cart_auto[iw, :]

                FF_R_rc_A = np.zeros((self.num_wann, self.num_wann, self.nRvec0, 3), dtype=complex)
                for iR in range(self.nRvec0):
                    for iw in range(self.num_wann):
                        for jw in range(self.num_wann):
                            rc_A = centers[jw, :] - centers[iw, :] + R_cart[iR, :]        
                            #FF_R_rc_A[iw, jw, iR, :] = AA_R[iw, jw, iR, alpha_A] * rc_A[beta_A] - AA_R[iw, jw, iR, beta_A] * rc_A[alpha_A]                  
                            FF_R_rc_A[iw, jw, iR, :] += -0.5 * AA_R_rc[iw, jw, iR, alpha_A] * rc_A[ beta_A]
                            FF_R_rc_A[iw, jw, iR, :] +=  0.5 * AA_R_rc[iw, jw, iR,  beta_A] * rc_A[alpha_A]
                            FF_R_rc_A[iw, jw, iR, :] +=  0.5 * rc_A[alpha_A] * AA_R_rc[iw, jw, iR,  beta_A]
                            FF_R_rc_A[iw, jw, iR, :] += -0.5 * rc_A[ beta_A] * AA_R_rc[iw, jw, iR, alpha_A]
                
                            FF_R[iw, jw, iR, :] = FF_R_recentered[iw, jw, iR, :] + FF_R_rc_A[iw, jw, iR, :]

            # Convention I method
            if transl_inv_OSD:
                FF_Rb = fourier_q_to_R_loc(FF_qb)
                # Sum over b vectors considering the phase factors
                for iR in range(self.nRvec0):
                    for ib1 in range(mmn.NNB):
                        for ib2 in range(mmn.NNB):
                            FF_R[:, :, iR, :] += FF_Rb[:, :, iR, ib1, ib2, :]

            self.set_R_mat('FF', FF_R)
            timeFFT += time() - t0
            del uiu

        ############################################################################################################

        if self.need_R_any(['SS', 'SR', 'SH', 'SHR']):
            spn = SPN(seedname)

        t0 = time()
        if self.need_R_any('SS'):
            self.set_R_mat('SS' ,fourier_q_to_R_loc(chk.get_SS_q(spn)))
        if self.need_R_any('SR'):
            self.set_R_mat('SR' , fourier_q_to_R_loc(chk.get_SR_q(spn, mmn)))
        if self.need_R_any('SH'):
            self.set_R_mat('SH' , fourier_q_to_R_loc(chk.get_SH_q(spn, eig)))
        if self.need_R_any('SHR'):
            self.set_R_mat('SHR' , fourier_q_to_R_loc(chk.get_SHR_q(spn, mmn, eig)))
        timeFFT += time() - t0
        try:
            del spn
        except NameError:
            pass


        if 'SA' in self.needed_R_matrices:
            siu = SIU(seedname)
            t0 = time()
            self.set_R_mat('SA', fourier_q_to_R_loc(chk.get_SA_q(siu, mmn)) )
            timeFFT += time() - t0
            del siu

        if 'SHA' in self.needed_R_matrices:
            shu = SHU(seedname)
            t0 = time()
            self.set_R_mat('SHA', fourier_q_to_R_loc(chk.get_SHA_q(shu, mmn)) )
            timeFFT += time() - t0
            del shu

        print("time for FFT_q_to_R : {} s".format(timeFFT))

        self.do_at_end_of_init()
        print("Real-space lattice:\n", self.real_lattice)

    def wigner_seitz(self, mp_grid):
        ws_search_size = np.array([1] * 3)
        dist_dim = np.prod((ws_search_size + 1) * 2 + 1)
        origin = divmod((dist_dim + 1), 2)[0] - 1
        real_metric = self.real_lattice.dot(self.real_lattice.T)
        mp_grid = np.array(mp_grid)
        irvec = []
        ndegen = []
        for n in iterate3dpm(mp_grid * ws_search_size):
            dist = []
            for i in iterate3dpm((1, 1, 1) + ws_search_size):
                ndiff = n - i * mp_grid
                dist.append(ndiff.dot(real_metric.dot(ndiff)))
            dist_min = np.min(dist)
            if abs(dist[origin] - dist_min) < 1.e-7:
                irvec.append(n)
                ndegen.append(np.sum(abs(dist - dist_min) < 1.e-7))

        return np.array(irvec), np.array(ndegen)
